module {
  moore.module @top_module(in %clk : !moore.l1, in %rst : !moore.l1, in %in_data : !moore.l4, out out_data : !moore.l4) {
    %clk_0 = moore.variable name "clk" : <l1>
    %rst_1 = moore.variable name "rst" : <l1>
    %in_data_2 = moore.variable name "in_data" : <l4>
    %out_data = moore.variable : <l4>
    %interconnect1 = moore.variable : <l4>
    %interconnect2 = moore.variable : <l4>
    %0 = moore.read %clk_0 : <l1>
    %1 = moore.read %rst_1 : <l1>
    %2 = moore.read %in_data_2 : <l4>
    %u1.data_out = moore.instance "u1" @module1(clk: %0: !moore.l1, rst: %1: !moore.l1, data_in: %2: !moore.l4) -> (data_out: !moore.l4)
    moore.assign %interconnect1, %u1.data_out : l4
    %3 = moore.read %clk_0 : <l1>
    %4 = moore.read %rst_1 : <l1>
    %5 = moore.read %interconnect1 : <l4>
    %u2.data_out = moore.instance "u2" @module2(clk: %3: !moore.l1, rst: %4: !moore.l1, data_in: %5: !moore.l4) -> (data_out: !moore.l4)
    moore.assign %interconnect2, %u2.data_out : l4
    %6 = moore.read %clk_0 : <l1>
    %7 = moore.read %rst_1 : <l1>
    %8 = moore.read %interconnect2 : <l4>
    %u3.data_out = moore.instance "u3" @module3(clk: %6: !moore.l1, rst: %7: !moore.l1, data_in: %8: !moore.l4) -> (data_out: !moore.l4)
    moore.assign %out_data, %u3.data_out : l4
    moore.assign %clk_0, %clk : l1
    moore.assign %rst_1, %rst : l1
    moore.assign %in_data_2, %in_data : l4
    %9 = moore.read %out_data : <l4>
    moore.output %9 : !moore.l4
  }
  moore.module private @module1(in %clk : !moore.l1, in %rst : !moore.l1, in %data_in : !moore.l4, out data_out : !moore.l4) {
    %clk_0 = moore.variable name "clk" : <l1>
    %rst_1 = moore.variable name "rst" : <l1>
    %data_in_2 = moore.variable name "data_in" : <l4>
    %data_out = moore.variable : <l4>
    moore.procedure always_ff {
      moore.wait_event {
        %15 = moore.read %clk_0 : <l1>
        moore.detect_event posedge %15 : l1
        %16 = moore.read %rst_1 : <l1>
        moore.detect_event posedge %16 : l1
      }
      %1 = moore.read %rst_1 : <l1>
      %2 = moore.conversion %1 : !moore.l1 -> i1
      cf.cond_br %2, ^bb1, ^bb2
    ^bb1:  // pred: ^bb0
      %3 = moore.constant 0 : i4
      %4 = moore.conversion %3 : !moore.i4 -> !moore.l4
      moore.nonblocking_assign %data_out, %4 : l4
      cf.br ^bb3
    ^bb2:  // pred: ^bb0
      %5 = moore.read %data_in_2 : <l4>
      %6 = moore.zext %5 : l4 -> l32
      %7 = moore.constant 1 : i32
      %8 = moore.conversion %7 : !moore.i32 -> !moore.l32
      %9 = moore.add %6, %8 : l32
      %10 = moore.constant 3 : i4
      %11 = moore.zext %10 : i4 -> i32
      %12 = moore.conversion %11 : !moore.i32 -> !moore.l32
      %13 = moore.xor %9, %12 : l32
      %14 = moore.trunc %13 : l32 -> l4
      moore.nonblocking_assign %data_out, %14 : l4
      cf.br ^bb3
    ^bb3:  // 2 preds: ^bb1, ^bb2
      moore.return
    }
    moore.assign %clk_0, %clk : l1
    moore.assign %rst_1, %rst : l1
    moore.assign %data_in_2, %data_in : l4
    %0 = moore.read %data_out : <l4>
    moore.output %0 : !moore.l4
  }
  moore.module private @module2(in %clk : !moore.l1, in %rst : !moore.l1, in %data_in : !moore.l4, out data_out : !moore.l4) {
    %clk_0 = moore.variable name "clk" : <l1>
    %rst_1 = moore.variable name "rst" : <l1>
    %data_in_2 = moore.variable name "data_in" : <l4>
    %data_out = moore.variable : <l4>
    moore.procedure always_ff {
      moore.wait_event {
        %11 = moore.read %clk_0 : <l1>
        moore.detect_event posedge %11 : l1
        %12 = moore.read %rst_1 : <l1>
        moore.detect_event posedge %12 : l1
      }
      %1 = moore.read %rst_1 : <l1>
      %2 = moore.conversion %1 : !moore.l1 -> i1
      cf.cond_br %2, ^bb1, ^bb2
    ^bb1:  // pred: ^bb0
      %3 = moore.constant 0 : i4
      %4 = moore.conversion %3 : !moore.i4 -> !moore.l4
      moore.nonblocking_assign %data_out, %4 : l4
      cf.br ^bb3
    ^bb2:  // pred: ^bb0
      %5 = moore.read %data_in_2 : <l4>
      %6 = moore.constant 1 : i32
      %7 = moore.shl %5, %6 : l4, i32
      %8 = moore.constant 1 : i4
      %9 = moore.conversion %8 : !moore.i4 -> !moore.l4
      %10 = moore.or %7, %9 : l4
      moore.nonblocking_assign %data_out, %10 : l4
      cf.br ^bb3
    ^bb3:  // 2 preds: ^bb1, ^bb2
      moore.return
    }
    moore.assign %clk_0, %clk : l1
    moore.assign %rst_1, %rst : l1
    moore.assign %data_in_2, %data_in : l4
    %0 = moore.read %data_out : <l4>
    moore.output %0 : !moore.l4
  }
  moore.module private @module3(in %clk : !moore.l1, in %rst : !moore.l1, in %data_in : !moore.l4, out data_out : !moore.l4) {
    %clk_0 = moore.variable name "clk" : <l1>
    %rst_1 = moore.variable name "rst" : <l1>
    %data_in_2 = moore.variable name "data_in" : <l4>
    %data_out = moore.variable : <l4>
    moore.procedure always_ff {
      moore.wait_event {
        %12 = moore.read %clk_0 : <l1>
        moore.detect_event posedge %12 : l1
        %13 = moore.read %rst_1 : <l1>
        moore.detect_event posedge %13 : l1
      }
      %1 = moore.read %rst_1 : <l1>
      %2 = moore.conversion %1 : !moore.l1 -> i1
      cf.cond_br %2, ^bb1, ^bb2
    ^bb1:  // pred: ^bb0
      %3 = moore.constant 0 : i4
      %4 = moore.conversion %3 : !moore.i4 -> !moore.l4
      moore.nonblocking_assign %data_out, %4 : l4
      cf.br ^bb3
    ^bb2:  // pred: ^bb0
      %5 = moore.read %data_in_2 : <l4>
      %6 = moore.constant -6 : i4
      %7 = moore.conversion %6 : !moore.i4 -> !moore.l4
      %8 = moore.xor %5, %7 : l4
      %9 = moore.constant 3 : i4
      %10 = moore.conversion %9 : !moore.i4 -> !moore.l4
      %11 = moore.add %8, %10 : l4
      moore.nonblocking_assign %data_out, %11 : l4
      cf.br ^bb3
    ^bb3:  // 2 preds: ^bb1, ^bb2
      moore.return
    }
    moore.assign %clk_0, %clk : l1
    moore.assign %rst_1, %rst : l1
    moore.assign %data_in_2, %data_in : l4
    %0 = moore.read %data_out : <l4>
    moore.output %0 : !moore.l4
  }
}
